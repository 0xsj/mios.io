// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: analytics.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createAnalyticsEntry = `-- name: CreateAnalyticsEntry :one

INSERT INTO analytics (
    item_id, user_id, ip_address, user_agent, referrer, page_view
) VALUES (
    $1, $2, $3, $4, $5, false
) RETURNING analytics_id, item_id, user_id, ip_address, user_agent, referrer, clicked_at, page_view
`

type CreateAnalyticsEntryParams struct {
	ItemID    uuid.UUID `json:"item_id"`
	UserID    uuid.UUID `json:"user_id"`
	IpAddress *string   `json:"ip_address"`
	UserAgent *string   `json:"user_agent"`
	Referrer  *string   `json:"referrer"`
}

// db/query/analytics.sql
// Recording clicks and page views
func (q *Queries) CreateAnalyticsEntry(ctx context.Context, arg CreateAnalyticsEntryParams) (*Analytic, error) {
	row := q.db.QueryRow(ctx, createAnalyticsEntry,
		arg.ItemID,
		arg.UserID,
		arg.IpAddress,
		arg.UserAgent,
		arg.Referrer,
	)
	var i Analytic
	err := row.Scan(
		&i.AnalyticsID,
		&i.ItemID,
		&i.UserID,
		&i.IpAddress,
		&i.UserAgent,
		&i.Referrer,
		&i.ClickedAt,
		&i.PageView,
	)
	return &i, err
}

const createPageViewEntry = `-- name: CreatePageViewEntry :one
INSERT INTO analytics (
    item_id, user_id, ip_address, user_agent, referrer, page_view
) VALUES (
    $1, $2, $3, $4, $5, true
) RETURNING analytics_id, item_id, user_id, ip_address, user_agent, referrer, clicked_at, page_view
`

type CreatePageViewEntryParams struct {
	ItemID    uuid.UUID `json:"item_id"`
	UserID    uuid.UUID `json:"user_id"`
	IpAddress *string   `json:"ip_address"`
	UserAgent *string   `json:"user_agent"`
	Referrer  *string   `json:"referrer"`
}

func (q *Queries) CreatePageViewEntry(ctx context.Context, arg CreatePageViewEntryParams) (*Analytic, error) {
	row := q.db.QueryRow(ctx, createPageViewEntry,
		arg.ItemID,
		arg.UserID,
		arg.IpAddress,
		arg.UserAgent,
		arg.Referrer,
	)
	var i Analytic
	err := row.Scan(
		&i.AnalyticsID,
		&i.ItemID,
		&i.UserID,
		&i.IpAddress,
		&i.UserAgent,
		&i.Referrer,
		&i.ClickedAt,
		&i.PageView,
	)
	return &i, err
}

const getContentItemClickCount = `-- name: GetContentItemClickCount :one
SELECT COUNT(*) FROM analytics
WHERE item_id = $1 AND page_view = false
`

// Count queries
func (q *Queries) GetContentItemClickCount(ctx context.Context, itemID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getContentItemClickCount, itemID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getItemAnalytics = `-- name: GetItemAnalytics :many
SELECT analytics_id, item_id, user_id, ip_address, user_agent, referrer, clicked_at, page_view FROM analytics
WHERE item_id = $1
ORDER BY clicked_at DESC
LIMIT $2 OFFSET $3
`

type GetItemAnalyticsParams struct {
	ItemID uuid.UUID `json:"item_id"`
	Limit  int64     `json:"limit"`
	Offset int64     `json:"offset"`
}

// Basic analytics queries
func (q *Queries) GetItemAnalytics(ctx context.Context, arg GetItemAnalyticsParams) ([]*Analytic, error) {
	rows, err := q.db.Query(ctx, getItemAnalytics, arg.ItemID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Analytic
	for rows.Next() {
		var i Analytic
		if err := rows.Scan(
			&i.AnalyticsID,
			&i.ItemID,
			&i.UserID,
			&i.IpAddress,
			&i.UserAgent,
			&i.Referrer,
			&i.ClickedAt,
			&i.PageView,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemAnalyticsByTimeRange = `-- name: GetItemAnalyticsByTimeRange :many
SELECT 
    DATE_TRUNC('day', clicked_at) AS day,
    COUNT(*) AS clicks
FROM analytics
WHERE item_id = $1
AND clicked_at >= $2
AND clicked_at <= $3
AND page_view = false
GROUP BY DATE_TRUNC('day', clicked_at)
ORDER BY day
`

type GetItemAnalyticsByTimeRangeParams struct {
	ItemID      uuid.UUID  `json:"item_id"`
	ClickedAt   *time.Time `json:"clicked_at"`
	ClickedAt_2 *time.Time `json:"clicked_at_2"`
}

type GetItemAnalyticsByTimeRangeRow struct {
	Day    time.Time `json:"day"`
	Clicks int64     `json:"clicks"`
}

func (q *Queries) GetItemAnalyticsByTimeRange(ctx context.Context, arg GetItemAnalyticsByTimeRangeParams) ([]*GetItemAnalyticsByTimeRangeRow, error) {
	rows, err := q.db.Query(ctx, getItemAnalyticsByTimeRange, arg.ItemID, arg.ClickedAt, arg.ClickedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetItemAnalyticsByTimeRangeRow
	for rows.Next() {
		var i GetItemAnalyticsByTimeRangeRow
		if err := rows.Scan(&i.Day, &i.Clicks); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfilePageViews = `-- name: GetProfilePageViews :one
SELECT COUNT(*) FROM analytics
WHERE user_id = $1 AND page_view = true
`

func (q *Queries) GetProfilePageViews(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getProfilePageViews, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getProfilePageViewsByDate = `-- name: GetProfilePageViewsByDate :many
SELECT 
    DATE_TRUNC('day', clicked_at) AS day,
    COUNT(*) AS views
FROM analytics
WHERE user_id = $1
AND clicked_at >= $2
AND clicked_at <= $3
AND page_view = true
GROUP BY DATE_TRUNC('day', clicked_at)
ORDER BY day
`

type GetProfilePageViewsByDateParams struct {
	UserID      uuid.UUID  `json:"user_id"`
	ClickedAt   *time.Time `json:"clicked_at"`
	ClickedAt_2 *time.Time `json:"clicked_at_2"`
}

type GetProfilePageViewsByDateRow struct {
	Day   time.Time `json:"day"`
	Views int64     `json:"views"`
}

func (q *Queries) GetProfilePageViewsByDate(ctx context.Context, arg GetProfilePageViewsByDateParams) ([]*GetProfilePageViewsByDateRow, error) {
	rows, err := q.db.Query(ctx, getProfilePageViewsByDate, arg.UserID, arg.ClickedAt, arg.ClickedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetProfilePageViewsByDateRow
	for rows.Next() {
		var i GetProfilePageViewsByDateRow
		if err := rows.Scan(&i.Day, &i.Views); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReferrerAnalytics = `-- name: GetReferrerAnalytics :many
SELECT 
    COALESCE(referrer, '') AS referrer,
    COUNT(*) AS count
FROM analytics
WHERE user_id = $1
AND clicked_at >= $2
AND clicked_at <= $3
AND referrer IS NOT NULL
GROUP BY referrer
ORDER BY count DESC
LIMIT $4
`

type GetReferrerAnalyticsParams struct {
	UserID      uuid.UUID  `json:"user_id"`
	ClickedAt   *time.Time `json:"clicked_at"`
	ClickedAt_2 *time.Time `json:"clicked_at_2"`
	Limit       int64      `json:"limit"`
}

type GetReferrerAnalyticsRow struct {
	Referrer string `json:"referrer"`
	Count    int64  `json:"count"`
}

func (q *Queries) GetReferrerAnalytics(ctx context.Context, arg GetReferrerAnalyticsParams) ([]*GetReferrerAnalyticsRow, error) {
	rows, err := q.db.Query(ctx, getReferrerAnalytics,
		arg.UserID,
		arg.ClickedAt,
		arg.ClickedAt_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetReferrerAnalyticsRow
	for rows.Next() {
		var i GetReferrerAnalyticsRow
		if err := rows.Scan(&i.Referrer, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopContentItemsByClicks = `-- name: GetTopContentItemsByClicks :many
SELECT 
    a.item_id,
    c.content_type,
    COALESCE(c.title, '') AS title,
    COUNT(*) AS click_count
FROM analytics a
JOIN content_items c ON a.item_id = c.item_id
WHERE c.user_id = $1
AND a.clicked_at >= $2
AND a.clicked_at <= $3
AND a.page_view = false
GROUP BY a.item_id, c.content_type, c.title
ORDER BY click_count DESC
LIMIT $4
`

type GetTopContentItemsByClicksParams struct {
	UserID      uuid.UUID  `json:"user_id"`
	ClickedAt   *time.Time `json:"clicked_at"`
	ClickedAt_2 *time.Time `json:"clicked_at_2"`
	Limit       int64      `json:"limit"`
}

type GetTopContentItemsByClicksRow struct {
	ItemID      uuid.UUID `json:"item_id"`
	ContentType string    `json:"content_type"`
	Title       string    `json:"title"`
	ClickCount  int64     `json:"click_count"`
}

// Insight queries
func (q *Queries) GetTopContentItemsByClicks(ctx context.Context, arg GetTopContentItemsByClicksParams) ([]*GetTopContentItemsByClicksRow, error) {
	rows, err := q.db.Query(ctx, getTopContentItemsByClicks,
		arg.UserID,
		arg.ClickedAt,
		arg.ClickedAt_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTopContentItemsByClicksRow
	for rows.Next() {
		var i GetTopContentItemsByClicksRow
		if err := rows.Scan(
			&i.ItemID,
			&i.ContentType,
			&i.Title,
			&i.ClickCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUniqueVisitors = `-- name: GetUniqueVisitors :one
SELECT COUNT(DISTINCT ip_address) 
FROM analytics
WHERE user_id = $1
AND clicked_at >= $2
AND clicked_at <= $3
AND ip_address IS NOT NULL
AND page_view = true
`

type GetUniqueVisitorsParams struct {
	UserID      uuid.UUID  `json:"user_id"`
	ClickedAt   *time.Time `json:"clicked_at"`
	ClickedAt_2 *time.Time `json:"clicked_at_2"`
}

// Visitor analytics
func (q *Queries) GetUniqueVisitors(ctx context.Context, arg GetUniqueVisitorsParams) (int64, error) {
	row := q.db.QueryRow(ctx, getUniqueVisitors, arg.UserID, arg.ClickedAt, arg.ClickedAt_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUniqueVisitorsByDay = `-- name: GetUniqueVisitorsByDay :many
SELECT 
    DATE_TRUNC('day', clicked_at) AS day,
    COUNT(DISTINCT ip_address) AS visitors
FROM analytics
WHERE user_id = $1
AND clicked_at >= $2
AND clicked_at <= $3
AND ip_address IS NOT NULL
AND page_view = true
GROUP BY DATE_TRUNC('day', clicked_at)
ORDER BY day
`

type GetUniqueVisitorsByDayParams struct {
	UserID      uuid.UUID  `json:"user_id"`
	ClickedAt   *time.Time `json:"clicked_at"`
	ClickedAt_2 *time.Time `json:"clicked_at_2"`
}

type GetUniqueVisitorsByDayRow struct {
	Day      time.Time `json:"day"`
	Visitors int64     `json:"visitors"`
}

func (q *Queries) GetUniqueVisitorsByDay(ctx context.Context, arg GetUniqueVisitorsByDayParams) ([]*GetUniqueVisitorsByDayRow, error) {
	rows, err := q.db.Query(ctx, getUniqueVisitorsByDay, arg.UserID, arg.ClickedAt, arg.ClickedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetUniqueVisitorsByDayRow
	for rows.Next() {
		var i GetUniqueVisitorsByDayRow
		if err := rows.Scan(&i.Day, &i.Visitors); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAnalytics = `-- name: GetUserAnalytics :many
SELECT analytics_id, item_id, user_id, ip_address, user_agent, referrer, clicked_at, page_view FROM analytics
WHERE user_id = $1
ORDER BY clicked_at DESC
LIMIT $2 OFFSET $3
`

type GetUserAnalyticsParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int64     `json:"limit"`
	Offset int64     `json:"offset"`
}

func (q *Queries) GetUserAnalytics(ctx context.Context, arg GetUserAnalyticsParams) ([]*Analytic, error) {
	rows, err := q.db.Query(ctx, getUserAnalytics, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Analytic
	for rows.Next() {
		var i Analytic
		if err := rows.Scan(
			&i.AnalyticsID,
			&i.ItemID,
			&i.UserID,
			&i.IpAddress,
			&i.UserAgent,
			&i.Referrer,
			&i.ClickedAt,
			&i.PageView,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAnalyticsByTimeRange = `-- name: GetUserAnalyticsByTimeRange :many
SELECT 
    DATE_TRUNC('day', clicked_at) AS day,
    COUNT(*) AS clicks
FROM analytics
WHERE user_id = $1
AND clicked_at >= $2
AND clicked_at <= $3
AND page_view = false
GROUP BY DATE_TRUNC('day', clicked_at)
ORDER BY day
`

type GetUserAnalyticsByTimeRangeParams struct {
	UserID      uuid.UUID  `json:"user_id"`
	ClickedAt   *time.Time `json:"clicked_at"`
	ClickedAt_2 *time.Time `json:"clicked_at_2"`
}

type GetUserAnalyticsByTimeRangeRow struct {
	Day    time.Time `json:"day"`
	Clicks int64     `json:"clicks"`
}

// Time range analytics
func (q *Queries) GetUserAnalyticsByTimeRange(ctx context.Context, arg GetUserAnalyticsByTimeRangeParams) ([]*GetUserAnalyticsByTimeRangeRow, error) {
	rows, err := q.db.Query(ctx, getUserAnalyticsByTimeRange, arg.UserID, arg.ClickedAt, arg.ClickedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetUserAnalyticsByTimeRangeRow
	for rows.Next() {
		var i GetUserAnalyticsByTimeRangeRow
		if err := rows.Scan(&i.Day, &i.Clicks); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserItemClickCount = `-- name: GetUserItemClickCount :one
SELECT COUNT(*) FROM analytics
WHERE user_id = $1 AND page_view = false
`

func (q *Queries) GetUserItemClickCount(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, getUserItemClickCount, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}
