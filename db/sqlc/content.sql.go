// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: content.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgtype"
)

const createContentItem = `-- name: CreateContentItem :one
INSERT INTO content_items (
    user_id, content_id, content_type, title, href, url, media_type,
    desktop_x, desktop_y, desktop_style, mobile_x, mobile_y, mobile_style,
    halign, valign, content_data, overrides, is_active
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18
) RETURNING item_id, user_id, content_id, content_type, title, href, url, media_type, desktop_x, desktop_y, desktop_style, mobile_x, mobile_y, mobile_style, halign, valign, content_data, overrides, is_active, created_at, updated_at, custom_styling, embed_data, auto_embed
`

type CreateContentItemParams struct {
	UserID       uuid.UUID    `json:"user_id"`
	ContentID    string       `json:"content_id"`
	ContentType  string       `json:"content_type"`
	Title        *string      `json:"title"`
	Href         *string      `json:"href"`
	Url          *string      `json:"url"`
	MediaType    *string      `json:"media_type"`
	DesktopX     *int32       `json:"desktop_x"`
	DesktopY     *int32       `json:"desktop_y"`
	DesktopStyle *string      `json:"desktop_style"`
	MobileX      *int32       `json:"mobile_x"`
	MobileY      *int32       `json:"mobile_y"`
	MobileStyle  *string      `json:"mobile_style"`
	Halign       *string      `json:"halign"`
	Valign       *string      `json:"valign"`
	ContentData  pgtype.JSONB `json:"content_data"`
	Overrides    pgtype.JSONB `json:"overrides"`
	IsActive     *bool        `json:"is_active"`
}

func (q *Queries) CreateContentItem(ctx context.Context, arg CreateContentItemParams) (*ContentItem, error) {
	row := q.db.QueryRow(ctx, createContentItem,
		arg.UserID,
		arg.ContentID,
		arg.ContentType,
		arg.Title,
		arg.Href,
		arg.Url,
		arg.MediaType,
		arg.DesktopX,
		arg.DesktopY,
		arg.DesktopStyle,
		arg.MobileX,
		arg.MobileY,
		arg.MobileStyle,
		arg.Halign,
		arg.Valign,
		arg.ContentData,
		arg.Overrides,
		arg.IsActive,
	)
	var i ContentItem
	err := row.Scan(
		&i.ItemID,
		&i.UserID,
		&i.ContentID,
		&i.ContentType,
		&i.Title,
		&i.Href,
		&i.Url,
		&i.MediaType,
		&i.DesktopX,
		&i.DesktopY,
		&i.DesktopStyle,
		&i.MobileX,
		&i.MobileY,
		&i.MobileStyle,
		&i.Halign,
		&i.Valign,
		&i.ContentData,
		&i.Overrides,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CustomStyling,
		&i.EmbedData,
		&i.AutoEmbed,
	)
	return &i, err
}

const deleteContentItem = `-- name: DeleteContentItem :exec
DELETE FROM content_items
WHERE item_id = $1
`

func (q *Queries) DeleteContentItem(ctx context.Context, itemID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteContentItem, itemID)
	return err
}

const getContentItem = `-- name: GetContentItem :one
SELECT item_id, user_id, content_id, content_type, title, href, url, media_type, desktop_x, desktop_y, desktop_style, mobile_x, mobile_y, mobile_style, halign, valign, content_data, overrides, is_active, created_at, updated_at, custom_styling, embed_data, auto_embed FROM content_items
WHERE item_id = $1 LIMIT 1
`

func (q *Queries) GetContentItem(ctx context.Context, itemID uuid.UUID) (*ContentItem, error) {
	row := q.db.QueryRow(ctx, getContentItem, itemID)
	var i ContentItem
	err := row.Scan(
		&i.ItemID,
		&i.UserID,
		&i.ContentID,
		&i.ContentType,
		&i.Title,
		&i.Href,
		&i.Url,
		&i.MediaType,
		&i.DesktopX,
		&i.DesktopY,
		&i.DesktopStyle,
		&i.MobileX,
		&i.MobileY,
		&i.MobileStyle,
		&i.Halign,
		&i.Valign,
		&i.ContentData,
		&i.Overrides,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CustomStyling,
		&i.EmbedData,
		&i.AutoEmbed,
	)
	return &i, err
}

const getUserContentItems = `-- name: GetUserContentItems :many
SELECT item_id, user_id, content_id, content_type, title, href, url, media_type, desktop_x, desktop_y, desktop_style, mobile_x, mobile_y, mobile_style, halign, valign, content_data, overrides, is_active, created_at, updated_at, custom_styling, embed_data, auto_embed FROM content_items
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetUserContentItems(ctx context.Context, userID uuid.UUID) ([]*ContentItem, error) {
	rows, err := q.db.Query(ctx, getUserContentItems, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ContentItem
	for rows.Next() {
		var i ContentItem
		if err := rows.Scan(
			&i.ItemID,
			&i.UserID,
			&i.ContentID,
			&i.ContentType,
			&i.Title,
			&i.Href,
			&i.Url,
			&i.MediaType,
			&i.DesktopX,
			&i.DesktopY,
			&i.DesktopStyle,
			&i.MobileX,
			&i.MobileY,
			&i.MobileStyle,
			&i.Halign,
			&i.Valign,
			&i.ContentData,
			&i.Overrides,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CustomStyling,
			&i.EmbedData,
			&i.AutoEmbed,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateContentItem = `-- name: UpdateContentItem :exec
UPDATE content_items
SET
    title = COALESCE($2, title),
    href = COALESCE($3, href),
    url = COALESCE($4, url),
    media_type = COALESCE($5, media_type),
    desktop_style = COALESCE($6, desktop_style),
    mobile_style = COALESCE($7, mobile_style),
    halign = COALESCE($8, halign),
    valign = COALESCE($9, valign),
    content_data = COALESCE($10, content_data),
    overrides = COALESCE($11, overrides),
    is_active = COALESCE($12, is_active),
    updated_at = CURRENT_TIMESTAMP
WHERE item_id = $1
`

type UpdateContentItemParams struct {
	ItemID       uuid.UUID    `json:"item_id"`
	Title        *string      `json:"title"`
	Href         *string      `json:"href"`
	Url          *string      `json:"url"`
	MediaType    *string      `json:"media_type"`
	DesktopStyle *string      `json:"desktop_style"`
	MobileStyle  *string      `json:"mobile_style"`
	Halign       *string      `json:"halign"`
	Valign       *string      `json:"valign"`
	ContentData  pgtype.JSONB `json:"content_data"`
	Overrides    pgtype.JSONB `json:"overrides"`
	IsActive     *bool        `json:"is_active"`
}

func (q *Queries) UpdateContentItem(ctx context.Context, arg UpdateContentItemParams) error {
	_, err := q.db.Exec(ctx, updateContentItem,
		arg.ItemID,
		arg.Title,
		arg.Href,
		arg.Url,
		arg.MediaType,
		arg.DesktopStyle,
		arg.MobileStyle,
		arg.Halign,
		arg.Valign,
		arg.ContentData,
		arg.Overrides,
		arg.IsActive,
	)
	return err
}

const updateContentItemPosition = `-- name: UpdateContentItemPosition :exec
UPDATE content_items
SET
    desktop_x = COALESCE($2, desktop_x),
    desktop_y = COALESCE($3, desktop_y),
    mobile_x = COALESCE($4, mobile_x),
    mobile_y = COALESCE($5, mobile_y),
    updated_at = CURRENT_TIMESTAMP
WHERE item_id = $1
`

type UpdateContentItemPositionParams struct {
	ItemID   uuid.UUID `json:"item_id"`
	DesktopX *int32    `json:"desktop_x"`
	DesktopY *int32    `json:"desktop_y"`
	MobileX  *int32    `json:"mobile_x"`
	MobileY  *int32    `json:"mobile_y"`
}

func (q *Queries) UpdateContentItemPosition(ctx context.Context, arg UpdateContentItemPositionParams) error {
	_, err := q.db.Exec(ctx, updateContentItemPosition,
		arg.ItemID,
		arg.DesktopX,
		arg.DesktopY,
		arg.MobileX,
		arg.MobileY,
	)
	return err
}
